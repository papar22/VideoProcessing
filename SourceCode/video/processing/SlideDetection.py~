# Import Basic modules

import numpy as np
import os 

# Import everything needed to edit video clips
from moviepy.editor import *
from moviepy.Clip import *
#from moviepy.video.tools.cuts import FramesMatches
#from moviepy.video.fx.crop import crop
from moviepy.video.VideoClip import *
from moviepy.config import get_setting # ffmpeg, ffmpeg.exe, etc...

#Importing ploting libraries for shoeing purposes
import matplotlib.pyplot as plt
from pylab import *

# Importing Opencv
import cv2



def rectify_coordinates(oldCoordinates):
        
    '''
    This function serves to rectify the coordinate of the detected slide area
    to the order like: [TOP-LEFT, TOP-RIGHT, BOTTOM-RIGHT, BOTTOM-LEFT ]
    '''
        
    oldCoordinates = oldCoordinates.reshape((4,2))
    newCoordinates = np.zeros((4,2),dtype = np.float32)

    add = oldCoordinates.sum(1)
    newCoordinates[0] = oldCoordinates[np.argmin(add)]
    newCoordinates[2] = oldCoordinates[np.argmax(add)]

    diff = np.diff(oldCoordinates,axis = 1)
    newCoordinates[1] = oldCoordinates[np.argmin(diff)]
    newCoordinates[3] = oldCoordinates[np.argmax(diff)]

    return newCoordinates   




class voting():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """ This class can be served for user cropping. After creating an instance of the class and
    call the corresponding method, a window will be open to get the user for points and then return 
    the points back."""
    
    
    def __init__(self, inputFile, listOfMethods):       
        self.inputFile = inputFile
        self.listOfMethods = listOfMethods
    
    def four_corner_points(self):
        
        inputVideo = self.inputFile
        
        
        obj = harris_corner_detection(inputVideo)
        points = obj.four_corner_points()
        

    
class harris_corner_detection():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """
        This function serves for Haris Corner Detector
        Inputs:
 
            src: Input single-channel 8-bit or floating-point image.
            blockSize:  Neighborhood size (see the details on cornerEigenValsAndVecs() ).
            kernelSize: Aperture parameter for the Sobel() operator.
            k: Harris detector free parameter. See the formula below.
            borderType: Pixel extrapolation method. See borderInterpolate() .
        Outputs:
            dst: Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src .

        Example:
        
        harris_corner_detection(inpuImage, blockSize=31, kernelSize=3, k=0.04,thersh=0.01, borderType)
        
    """
      
    
    def __init__(self, inputFile, blockSize, kernelSize, k, borderType, thersh, flagShow):       
        self.inputFile = inputFile
        self.blockSize = blockSize
        self.kernelSize = kernelSize 
        self.k = k
        self.borderType = borderType
        self.thresh = thresh
        self.flagShow = flagShow
        
    def four_corner_points(self):
        
     
        image = self.inputFile
        grayImage = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
        grayImage = np.float32(grayImage)
        dst = cv2.cornerHarris(grayImage,self.blockSize,self.kernelSize,self.k, self.borderType)

        #result is dilated for marking the corners, not important
        dst = cv2.dilate(dst,None)

        # Threshold for an optimal value, it may vary depending on the image.
        imgc = image.copy()
        imgc[dst > (self.thersh)*dst.max()]=[0,255,0]
        x,y = np.where(dst > (self.thersh)*dst.max())
        arrayHarrisPoints = np.zeros((len(x),2), dtype=float)
        arrayHarrisPoints[:,0] = x
        arrayHarrisPoints[:,1] = y
        
        if self.flagShow :
            plt.imshow(imgc, cmap = cm.Greys_r)
            plt.show()
            
        return arrayHarrisPoints
    
    
        
class sum_all_differences_frames():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """ This class can be served for getting the sum of the difference of the pixel value of selected frames. 
    After creating an instance of the class and call the corresponding method, 
    a window will be open to get the user for points and then return the points back."""
    
    '''
    This function serves for max of all frames
    Inputs:       
        marginToReadFrames: The amount of seconds from the beginning and end of the video
                                to read the frames and calculate the sum of them.
        flagShow: If true, the final summed frame has been shown.

    Outputs:
        summedFrame: The final 2D-image is the max of all frames between 
                         (video.duration)-marginToReadFrames - marginToReadFrames).

    Example:
        sum_all_differences_frames(inputVideo, marginToReadFrames=20, flagShow=True)
        
    '''    
    
    
    def __init__(self, inputFile, marginToReadFrames, flagShow):       
        self.inputFile = inputFile
        self.marginToReadFrames = marginToReadFrames
        self.flagShow = flagShow    
        

    def four_corner_points(self):
        
        
        video = self.inputFile
        W,H = video.size
        
        finalDiffSum = np.zeros((H,W), dtype=float)
        marginToReadFrames = self.marginToReadFrames
        counter = 0
        for t in frange(marginToReadFrames, int(video.duration)-marginToReadFrames, (1/video.fps)):
    
            # Getting the frame 
            firstSlide = cv2.cvtColor( video.get_frame(t), cv2.COLOR_RGB2GRAY )
            firstSlide = firstSlide.astype('int16')

            # Getting the frame 
            secondSlide = cv2.cvtColor( video.get_frame(t + (1/video.fps)), cv2.COLOR_RGB2GRAY )
            secondSlide = secondSlide.astype('int16')


            dif = secondSlide - firstSlide
            finalDiffSum = finalDiffSum + dif
            counter = counter + 1
        
        finalDiffSumNorm = finalDiffSum/counter
        
        if self.flagShow:
            plt.imshow(finalDiffSumNorm, cmap = cm.Greys_r)
            plt.show()
                    
        return finalDiffSumNorm
    

 

        
class sum_all_differences_frames():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """ This class can be served for getting the max of the difference of the pixel value of selected frames. 
    After creating an instance of the class and call the corresponding method, 
    a window will be open to get the user for points and then return the points back.
    """
    
    '''
    This function serves for max of all frames
    Inputs:       
        marginToReadFrames: The amount of seconds from the beginning and end of the video
                                to read the frames and calculate the sum of them.
        flagShow: If true, the final summed frame has been shown.

    Outputs:
        summedFrame: The final 2D-image is the max of all frames between 
                         (video.duration)-marginToReadFrames - marginToReadFrames).

    Example:
        sum_all_differences_frames(inputVideo, marginToReadFrames=20, flagShow=True)
    '''
        

    
    
    
    def __init__(self, inputFile, marginToReadFrames, flagShow):       
        self.inputFile = inputFile
        self.marginToReadFrames = marginToReadFrames
        self.flagShow = flagShow

    def four_corner_points(self):
        
        '''
        This function serves for max of the differences of all frames
        Inputs:
        
            marginToReadFrames: The amount of seconds from the beginning and end of the video
                                to read the frames and calculate the sum of them.
            flagShow: If true, the final summed frame has been shown.

        Outputs:
            summedFrame: The final 2D-image is the max of the difference of all frames between 
                         (video.duration)-marginToReadFrames - marginToReadFrames).

        Example:
        
        sum_all_differences_frames(inputVideo, marginToReadFrames=20, flagShow=True)
        
        '''
        
        video = self.inputFile
        W,H = video.size
        
        finalDiffMax = np.zeros((H,W), dtype=float)
        marginToReadFrames = self.marginToReadFrames
        counter = 0
        for t in frange(marginToReadFrames, int(video.duration)-marginToReadFrames, (1/video.fps)):
    
            # Getting the frame 
            firstSlide = cv2.cvtColor( video.get_frame(t), cv2.COLOR_RGB2GRAY )
            firstSlide = firstSlide.astype('int16')

            # Getting the frame 
            secondSlide = cv2.cvtColor( video.get_frame(t + (1/video.fps)), cv2.COLOR_RGB2GRAY )
            secondSlide = secondSlide.astype('int16')


            dif = secondSlide - firstSlide
            finalDiffMax = np.maximum(finalDiffMax ,dif)
            counter = counter + 1
        
        finalDiffMaxNorm = finalDiffMax/counter
        
        if self.flagShow:
            plt.imshow(finalDiffMaxNorm, cmap = cm.Greys_r)
            plt.show()
                    
        return finalDiffMaxNorm





class max_all_frames():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """ This class can be served for getting the max pixel value of selected frames. 
    After creating an instance of the class and call the corresponding method, 
    a window will be open to get the user for points and then return the points back."""
    
    '''
    This function serves for max of all frames
    Inputs:       
        marginToReadFrames: The amount of seconds from the beginning and end of the video
                                to read the frames and calculate the sum of them.
        flagShow: If true, the final summed frame has been shown.

    Outputs:
        summedFrame: The final 2D-image is the max of all frames between 
                         (video.duration)-marginToReadFrames - marginToReadFrames).

    Example:
        sum_all_differences_frames(inputVideo, marginToReadFrames=20, flagShow=True)
        
    ''' 
    
    
    
    def __init__(self, inputFile, marginToReadFrames, flagShow):       
        self.inputFile = inputFile
        self.marginToReadFrames = marginToReadFrames
        self.flagShow = flagShow

    def four_corner_points(self):
                  
        video = self.inputFile
        W,H = video.size
        
        finalMax = np.zeros((H,W), dtype=float)
        finalMax1 = np.zeros((H,W), dtype=float)
        marginToReadFrames = self.marginToReadFrames
        counter = 0
        for t in frange(marginToReadFrames, int(video.duration)-marginToReadFrames, (1/video.fps)):
    
            # Getting the frame 
            firstSlide = cv2.cvtColor( video.get_frame(t), cv2.COLOR_RGB2GRAY )
            firstSlide = firstSlide.astype('int16')

            # Getting the frame 
            secondSlide = cv2.cvtColor( video.get_frame(t + (1/video.fps)), cv2.COLOR_RGB2GRAY )
            secondSlide = secondSlide.astype('int16')


            finalMax1 = np.maximum(secondSlide ,firstSlide)
            finalMax = np.maximum(finalMax1 ,finalMax)
            counter = counter + 1
        
        finalMaxNorm = finalMax/counter
        
        if self.flagShow:
            plt.imshow(finalMaxNorm, cmap = cm.Greys_r)
            plt.show()
                    
        return finalMaxNorm  




class get_user_cropping():

    # documentation string, which can be accessed via ClassName.__doc__ 
    """ This class can be served for user cropping. After creating an instance of the class and
    call the corresponding method, a window will be open to get the user for points and then return 
    the points back."""
    
    
    def __init__(self, inputFile):       
      self.inputFile = inputFile
    
    def four_corner_points(self):
        
        inputFrame = self.inputFile
        fig = plt.figure()
        plt.imshow(inputFrame)
        plt.title('Please click the top left, bottom left, bottom right and top right corners \
        and then close the window.')

        objectCallbacksPoints = CallbacksPoints(inputFrame.shape[:2])
        objectCallbacksPoints.connect(fig)    
        plt.show()
        selectedPoints = objectCallbacksPoints.get_points()
        return rectify_coordinates(np.array(selectedPoints, dtype=np.float32))


class CallbacksPoints:
    def __init__(self,image_size):
        self.start_point = []
        self.end_point = []
        self.image_size=image_size

        self.points = []

        self.next_point = 0
        self.const_lines = []

        self.h = 0
        self.w = 0
        self.deg = 0
        
        self.lx = []
        self.ly = []

    def callback_press(self,event):
        if self.next_point > 3:
            return
            
        self.next_point += 1            
        self.points.append([event.xdata,event.ydata])

        if self.next_point > 1:
            self.draw_lines(event,redraw=True)

    def draw_lines(self,event,redraw=False):
        assert(len(self.points)>1)

        ax = event.inaxes

        for x in range(len(self.points)-1):
            # draw line from self.points[x] to self.points[x+1]
            p0 = self.points[x]
            p1 = self.points[x+1]
            ax.plot([p0[0],p1[0]],[p0[1],p1[1]],'r',linewidth=1)

        if redraw:
            ax.set_xlim(0,self.image_size[1])
            ax.set_ylim(self.image_size[0],0)
            ax.figure.canvas.draw()
    

    def callback_motion(self,event):
    
        if not event.inaxes: return
        
        x1 = event.xdata
        y1 = event.ydata

        ax = event.inaxes
        ax.lines = []
        
        
        self.lx = ax.axhline(color='k')  # the horiz line
        self.ly = ax.axvline(color='k')  # the vert line
        
        if (len(self.points) > 0) and (len(self.points) <= 3):
            
            x0 = self.points[-1][0]
            y0 = self.points[-1][1]
            
            ax.plot([x0,x1],[y0,y1],'r',linewidth=1)

            ax.set_xlim(0,self.image_size[1])
            ax.set_ylim(self.image_size[0],0)
            
        if len(self.points)>1:
            self.draw_lines(event)
        
        self.lx.set_ydata(y1)
        self.ly.set_xdata(x1)

        ax.figure.canvas.draw()


    def connect(self,fig):
        fig.canvas.mpl_connect('button_press_event', self.callback_press)
        fig.canvas.mpl_connect('motion_notify_event', self.callback_motion)

    def get_x0(self):
        return self.points[0][0]
    def get_y0(self):
        return self.points[0][1]
    def get_rect(self):
        return (self.points[0][0], #x0
                self.points[0][1], #y0
                self.w,
                self.h,
                self.deg_grad)

    def get_points(self):
        if self.next_point > 3:
            return self.points
        else:
            return []

        


if __name__ == '__main__':
    
    

    
